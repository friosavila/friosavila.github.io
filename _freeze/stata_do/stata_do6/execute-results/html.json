{
  "hash": "2faa747703cbc6744bf3401cf486e585",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Marginal effects with nonlinear transformations: `f_able`\"\nsubtitle: \"Featuring @rios-avila_estimation_2021\"\ncode-fold: false\nbibliography: mywork.bib\n---\n\n## Introduction\n\n:::{.callout-note}\n\nIf you are interested only on the program `f_able`, please jump to the last section\n\n:::\n\nIn both classroom discussions and online forums like [`statalist`](https://www.statalist.org/forums/forum/general-stata-discussion/general), a recurring question revolves around the estimation of marginal effects within models that incorporate nonlinear transformations of key variables.\n\nThis question is challenging because we, the analalists, are more familiar with model specifications that exclusively involve variables in their original forms. Few of us dare to explore the inclusion of quadratic or cubic terms, or the introduction of interactions among continuous variables. In the past, calculating marginal effects under such circumstances required additional effort: computing partial derivatives, and obtaining both point estimates and standard errors.\n\nFor linear models, things are simple, as marginal effects are constant and equal to their coefficients. Even in non-linear models, where the effect varies based on characteristics, estimating marginal effects remains relatively easy, either manually or with the help of most software tools.\n\nStarting from version 14, `Stata` is able to compute marginal effects when interactions and polynomials are present, using the `margins` command, as long as the formulations are expressed in a manner that `Stata` can understand. Virtually all official commands, as well as numerous community-contributed ones, offer this functionality. However, when dealing with more complex transformations, like fractional polynomials or spline bases, manual derivation of these effects are still necessary.\n\nBut surely, there's a more efficient way!\n\nIn @rios-avila_estimation_2021, I introduced a user-friendly command designed to simplify the estimation of marginal effects, regardless of the specific functional forms applied to the data, that can be used with most commands. In the following sections, I'll provide an overview of the correct approach to estimating marginal effects, describe how the margins command operates, and explain how you can employ `f_able` to calculate marginal effects for models that might otherwise pose challenges.\n\n## Marginal effects: Analytical approach\n\nLets start with a simple linear model:\n\n$$\\begin{aligned}\ny &=\\beta_0+\\beta_1 x_1 + \\beta_2 x_2 + \\beta_3 x_3 + e \\\\\nE(y|x) &= \\beta_0+\\beta_1 x_1 + \\beta_2 x_2 + \\beta_3 x_3 \n\\end{aligned}\n$${#eq-eq1}\n\nIn this model, marginal effects are directly given by the model coefficients:\n\n$$\\frac{\\partial E(y|x)}{\\partial x_k} = \\beta_k\n$$\n\nWhich greatly simplifies the analysis.\n\nIf the model has interactions or polynomials, marginal effects are somewhat more challenging:\n\n$$\\begin{aligned}\nE(y|x) = \\beta_0+\\beta_1 x_1 + \\beta_2 x_2 + \\beta_3 x_1 \\times x_2  + \\beta_4 x_2^2\n\\end{aligned}\n$${#eq-eq3}\n\nwhere the marginal effects would be given by:\n\n$$\\begin{aligned}\n\\frac{\\partial E(y|x)}{\\partial x_1} &= \\beta_1 + \\beta_3 x_2 \\\\\n\\frac{\\partial E(y|x)}{\\partial x_2} &= \\beta_2 + \\beta_3 x_1 + 2 \\beta_4 x_2\n\\end{aligned}\n$$\n\nThese effects are not constant. They vary based on values of $x_1$ and $x_2$. Knowing some calculus, however, its rather straight forward to determine the marginal effects, and apply that to our work. \n\nSo lets see an example of this. First the setup:\n\n::: {#5c6da623 .cell execution_count=1}\n``` {.stata .cell-code code-fold=\"false\"}\nclear\nset linesize 255\nset seed 1\nset obs 1000           // Create a sample of 100 obs\ngen x1 = runiform(0,4) // Create two variables with mean 2\ngen x2 = runiform(0,4) //\n// create auxiliary variables\ngen x1x2=x1*x2\ngen x2sqr=x2^2\n// and set up the coefficient values\nscalar b0 = 2\nscalar b1 = 1\nscalar b2 = 1\nscalar b3 = 1\nscalar b4 = 1\ngen y = b0 + b1 * x1 + b2 * x2 + b3 * x1x2 + b4 * x2sqr + rnormal()\n```\n:::\n\n\nNow, we can estimate the model and obtain marginal effects based on the analytical solution:\n\n``` {.stata .cell-code code-fold=\"false\"}\nqui:reg y x1 x2 x1x2 x2sqr\n```\n\n\nwhich gives us the following\n\n$$\nE(y|X) = 1.953 + 1.046 x1 + 0.944 x2 + 1.019 x1x2 + 1.005 x2sqr\n\nN =       1000  R^2 = 0.989\n$$\n\n\nFrom where we can estimate marginal effects using the analytical formulas we derived.\n\n::: {#cbc6cc1b .cell execution_count=4}\n``` {.stata .cell-code code-fold=\"false\"}\nmargins, expression(_b[x2]+_b[x1x2]*x1+2*_b[x2sqr]*x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwarning: option expression() does not contain option predict() or xb().\n\nPredictive margins                                       Number of obs = 1,000\nModel VCE: OLS\n\nExpression: _b[x2]+_b[x1x2]*x1+2*_b[x2sqr]*x2\n\n------------------------------------------------------------------------------\n             |            Delta-method\n             |     Margin   std. err.      z    P>|z|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n       _cons |   7.131659   .0265967   268.14   0.000      7.07953    7.183787\n------------------------------------------------------------------------------\n```\n:::\n:::\n\n\nNoticed I used margins `expression`, to allow me estimate average marginal effects using the analytical solutions. Technically, what we see is the average prediction of the expression we provided. We, of course, know they are right, because we know calculus.\n\nYou could use a similar approach to estimate marginal effects based on any transformation (as long as you know the how to obtain the partial derivative)\n\n## Marginal effects: `margins`\n\nAs mentioned earlier, `Stata` command `margins` allows you to estimate marginal effects of almost any model, as long as it understands the inter-relationships among variables. So lets see what would have happend if I use it in my previous model:\n\n::: {#f040b705 .cell execution_count=5}\n``` {.stata .cell-code code-fold=\"false\"}\nmargins, dydx(x1 x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nAverage marginal effects                                 Number of obs = 1,000\nModel VCE: OLS\n\nExpression: Linear prediction, predict()\ndy/dx wrt:  x1 x2\n\n------------------------------------------------------------------------------\n             |            Delta-method\n             |      dy/dx   std. err.      t    P>|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n          x1 |   1.045827   .0563175    18.57   0.000     .9353127    1.156342\n          x2 |   .9437094   .1142363     8.26   0.000     .7195376    1.167881\n------------------------------------------------------------------------------\n```\n:::\n:::\n\n\nWe get something that is wrong. Instead of estimating the correct marginal effects, it is only showing the coefficients for $x_1$ and $x_2$. The reason for this is that `margins` has no way to know that the variables $x1x2$ and $x2sqr$ are in fact functions of $x_1$ and $x_2$. Not at least we use the correct syntax.\n\nIn `Stata`, interactions and polynomials can be added to the model specification using \"#\", and indicating the type of variable one is using. In this case, I use \"**c.**\" because $x_1$ and $x_2$ are continuous variables. See `help fvvarlist`, for more information.\n\n::: {#63f15c74 .cell execution_count=6}\n``` {.stata .cell-code code-fold=\"false\"}\nqui:reg y c.x1 c.x2 c.x1#c.x2 c.x2#c.x2\nmargins, dydx(x1 x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nAverage marginal effects                                 Number of obs = 1,000\nModel VCE: OLS\n\nExpression: Linear prediction, predict()\ndy/dx wrt:  x1 x2\n\n------------------------------------------------------------------------------\n             |            Delta-method\n             |      dy/dx   std. err.      t    P>|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n          x1 |   3.128384   .0283469   110.36   0.000     3.072757     3.18401\n          x2 |   7.131659   .0265967   268.14   0.000     7.079467    7.183851\n------------------------------------------------------------------------------\n```\n:::\n:::\n\n\nNow we get the same result as earlier because `Stata` understands that $x_2^2$ or `c.x2#c.x2` is a new variable that depends on $x_2$. Similar for $x_1$.\n\nThe key, then, is to ***teach*** `Stata` that certain variables are indeed function of others. Here is where `f_able` enters into play.\n\n## How does `margins` work? and why `f_able`?\n\n@fig-fig1 provies an sketch of how `margins` work when estimating a model.\n\n1. Get the data, with correct model specifications.\n2. Estimate the model, which creates the `e(b)` and `e(V)`, which contains all the data necessairy to estimate the marginal effects.\n3. `margins` makes a small change in $x's$ to obtain numerical derivatives.\n4. Calls on `predict` to get the predicted values of interest\n5. Calculates marginal effects, and reports them.\n \n![How `margins` work?](Diag_1.png){#fig-fig1}\n\nThe problem with using data that we create before the model has to do with step 3. \n\nThe change induced on $x$ will not be reflected in $GX$, because there is nothing to tie them together.\n\n![Why `margins` fails?](Diag_2.png){#fig-fig2}\n\n@fig-fig3 shows how `f_able` helps solving this problems.\n\n1. When creating the data with `fgen`, additional information will be added to show how that data was generated. \n2. After estimating the model, `f_able` will add information to the `e()` so it nows what variables depend on others (those created with `fgen`).\n3. Finally, `f_able_p` acts as an intermediary to update all \"created variables\" during the numerical differentiation process.\n\n![How does `f_able` helps?](Diag_3.png){#fig-fig3}\n\n## Using `f_able` to estimate margins for any transformation.\n\n### Setup\n\nYou can download `f_able` from SSC. However, the latest version will be avaible from my repository. To do so, type:\n\n```stata\n* Opt 1. Get Fra installer\nnet install fra, replace from(https://friosavila.github.io/stpackages)\nfra install f_able, replace\n \n* Opt 2. Install it from here directly\nnet install f_able, replace from(https://friosavila.github.io/stpackages)\n\n* Opt 3. Use SSC\nssc install f_able\n```\n\n### Re-doing the example\n\nSo, lets retake the previous example. We know that the \"offending\" variables were  `x1x2` and  `x2sqr`. So lets recreate them using `fgen`.\n\n::: {#ebfc8dd0 .cell execution_count=7}\n``` {.stata .cell-code code-fold=\"false\"}\ndrop x1x2 x2sqr\nfgen x1x2  = x1*x2\nfgen x2sqr = x2*x2\n```\n:::\n\n\nNow, lets estimate the model of interest, but adding a line indicating what variables are \"created\" variables:\n\n::: {#aa12c1c6 .cell execution_count=8}\n``` {.stata .cell-code code-fold=\"false\"}\nqui:reg y x1 x2 x1x2 x2sqr\n** This line is necessary\nf_able x1x2 x2sqr, auto\n** option Auto, makes some of the processing easier\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is an experimental feature in f_able\nUsing this option, you do not need to add nochain or numerical options in margins\nAll variables in -nlvar- have been declared\n```\n:::\n:::\n\n\nFinally, lets estimate the marginal effects again\n\n::: {#809edd7f .cell execution_count=9}\n``` {.stata .cell-code code-fold=\"false\"}\nmargins, dydx(*)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nAverage marginal effects                                 Number of obs = 1,000\nModel VCE: OLS\n\nExpression: Fitted values, predict()\ndy/dx wrt:  x1 x2\n\n------------------------------------------------------------------------------\n             |            Delta-method\n             |      dy/dx   std. err.      z    P>|z|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n          x1 |   3.128384   .0283469   110.36   0.000     3.072825    3.183942\n          x2 |   7.131659   .0265967   268.14   0.000      7.07953    7.183787\n------------------------------------------------------------------------------\n```\n:::\n:::\n\n\n### What if $x$ is no longer in the main model\n\nThere are a few other cases that may be of interest. Consider the previous model, and assume we are only interested in adding the quadratic term in the model, not the linear one.\n\nUsing factor notation, one could do the following:\n\n::: {#f5d9fb90 .cell execution_count=10}\n``` {.stata .cell-code code-fold=\"false\"}\nqui:reg y c.x2#c.x2\nmargins, dydx(*)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nAverage marginal effects                                 Number of obs = 1,000\nModel VCE: OLS\n\nExpression: Linear prediction, predict()\ndy/dx wrt:  x2\n\n------------------------------------------------------------------------------\n             |            Delta-method\n             |      dy/dx   std. err.      t    P>|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n          x2 |     7.1484    .103735    68.91   0.000     6.944836    7.351963\n------------------------------------------------------------------------------\n```\n:::\n:::\n\n\nUsing `f_able`, however, you still need to include the original variable in the model. This can be done using the \"o.\" prefix, so that the variable is ommitted, from calculations, but remain in the model.\n\n::: {#be96f0b1 .cell execution_count=11}\n``` {.stata .cell-code code-fold=\"false\"}\nqui:reg y x2sqr o.x2\nf_able x2sqr, auto\nmargins, dydx(*)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is an experimental feature in f_able\nUsing this option, you do not need to add nochain or numerical options in margins\nAll variables in -nlvar- have been declared\n\nAverage marginal effects                                 Number of obs = 1,000\nModel VCE: OLS\n\nExpression: Fitted values, predict()\ndy/dx wrt:  x2\n\n------------------------------------------------------------------------------\n             |            Delta-method\n             |      dy/dx   std. err.      z    P>|z|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n          x2 |     7.1484    .103735    68.91   0.000     6.945083    7.351717\n------------------------------------------------------------------------------\n```\n:::\n:::\n\n\nAlright, these are very simple examples that you could already do with margins. So lets try something different. Estimate a model using $x$ and $\\sqrt x$ as explanatory variables:\n\n::: {#e399069b .cell execution_count=12}\n``` {.stata .cell-code code-fold=\"false\"}\nfgen rx1=x1^.5\nqui:reg y x1 rx1\nf_able rx1, auto\nmargins, dydx(*)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is an experimental feature in f_able\nUsing this option, you do not need to add nochain or numerical options in margins\nAll variables in -nlvar- have been declared\n\nAverage marginal effects                                 Number of obs = 1,000\nModel VCE: OLS\n\nExpression: Fitted values, predict()\ndy/dx wrt:  x1\n\n------------------------------------------------------------------------------\n             |            Delta-method\n             |      dy/dx   std. err.      z    P>|z|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n          x1 |   3.332656   .3268743    10.20   0.000     2.691994    3.973318\n------------------------------------------------------------------------------\n```\n:::\n:::\n\n\nHow do we know is correct? We can replicate the results using `nl`!. Technically, it works in a similar way as `f_able` does.\n\n::: {#2f23db75 .cell execution_count=13}\n``` {.stata .cell-code code-fold=\"false\"}\nqui:nl (y={b0}+{b1}*x1+{b2}*x1^0.5), variable(x1)\nmargins, dydx(*)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nAverage marginal effects                                 Number of obs = 1,000\nModel VCE: GNR\n\nExpression: Fitted values, predict()\ndy/dx wrt:  x1\n\n------------------------------------------------------------------------------\n             |            Delta-method\n             |      dy/dx   std. err.      z    P>|z|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n          x1 |   3.332656   .3268743    10.20   0.000     2.691994    3.973318\n------------------------------------------------------------------------------\n```\n:::\n:::\n\n\nSomething even harder? What about a poisson regression:\n\n::: {#65fa8a3f .cell execution_count=14}\n``` {.stata .cell-code code-fold=\"false\"}\nqui:poisson y x1 x2 x1x2 x2sqr\nqui:f_able x1x2 x2sqr, auto\nmargins, dydx(*)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nAverage marginal effects                                 Number of obs = 1,000\nModel VCE: OIM\n\nExpression: Predicted number of events, predict()\ndy/dx wrt:  x1 x2\n\n------------------------------------------------------------------------------\n             |            Delta-method\n             |      dy/dx   std. err.      z    P>|z|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n          x1 |   3.168351   .1185385    26.73   0.000      2.93602    3.400683\n          x2 |   7.004783   .1513991    46.27   0.000     6.708046     7.30152\n------------------------------------------------------------------------------\n```\n:::\n:::\n\n\nAnother implementation some people usually ask for is the estimation of marginal effects when using\nsplines, either regular polynomial splines, or restricted cubic splines.\n\nBecause splines are messy to code, instead of using `fgen`, we can use `f_spline` or `f_rcspline`. Let's use both:\n\n::: {#d8f9afb3 .cell execution_count=15}\n``` {.stata .cell-code code-fold=\"false\"}\nwebuse dui, clear\n* model citation=f(fines)+e\n* Cubic polynomial spline with 1 knot\nf_spline spfine=fines, degree(3) nknots(1)\n* Restricted Cubic polynomial with 5 knots \nf_rcspline cspfine=fines,  nknots(5) replace\n* Different from other commands,\n* f_spline and  f_rcspline use\n* the original variable as part of the splines\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Fictional data on monthly drunk driving citations)\n```\n:::\n:::\n\n\nNow lets estimate both models:\n\n``` {.stata .cell-code code-fold=\"false\"}\nqui:reg citations fines spfine2 spfine3 spfine4\nqui:f_able spfine2 spfine3 spfine4, auto\nqui:emargins , dydx(fines) estore(m1)\nqui:reg citations fines cspfine2 cspfine3 cspfine4\nqui:f_able cspfine2 cspfine3 cspfine4, auto\nqui:emargins , dydx(fines) estore(m2)\nqui:reg citations fines\nqui:emargins , dydx(fines) estore(m3)\ndisplay \"#### Contrasting Models\"\nesttab m1 m2 m3, nonum mtitle(\"Cubic Spline\" \"RCubic Spline\" \"LM\") md se note(\"Contrasting effects\")\n```\n#### Contrasting Models\n\n\n|              | Cubic Spline                  | RCubic Spline                  |           LM                  |\n| ------------ | :---------------------------: | :---------------------------: | :---------------------------: |\n| fines        |       -7.911<sup>\\*\\*\\*</sup> |       -7.965<sup>\\*\\*\\*</sup> |       -7.960<sup>\\*\\*\\*</sup> |\n|              |      (0.424)                  |      (0.422)                  |      (0.434)                  |\n| *N*          |          500                  |          500                  |          500                  |\n\nContrasting effects<br>\n<sup>\\*</sup> *p* < 0.05, <sup>\\*\\*</sup> *p* < 0.01, <sup>\\*\\*\\*</sup> *p* < 0.001\n\n\n\nOf course, when using splines, it may be far more interesting plotting the effects across values of $fines$. \n\n::: {#fig-dui .cell layout-ncol='2' execution_count=17}\n``` {.stata .cell-code code-fold=\"false\"}\nset scheme white2\ncolor_style tableau\nqui:reg citations fines spfine2 spfine3 spfine4\nqui:f_able spfine2 spfine3 spfine4, auto\nqui:emargins , at(fines=(8(0.125)12)) \nqui:marginsplot, name(m1, replace)\nqui:emargins , dydx(fines) at(fines=(8(0.125)12))  \nqui:marginsplot, name(m2, replace)\n```\n\n::: {.cell-output .cell-output-display}\n![Predicted mean](stata_do6_files/figure-html/fig-dui-output-1.png){#fig-dui-1}\n:::\n\n::: {.cell-output .cell-output-display}\n![Marginal effect](stata_do6_files/figure-html/fig-dui-output-2.png){#fig-dui-2}\n:::\n\nPredictive mean vs Marginal efects\n:::\n\n\n## Conclusions\n\n`f_able` is a relatively simple program that allows you to estimate marginal effects of unconventional variable transformations. \n\nWhile I have tried to make `f_able` as flexible as possible, couple of challenges remain. \n\n1. `f_able` relies on numerical differentiation, which can be very time consuming in some models. \n2. When the model is fairly complex, think about interactions of splines and other variables, margins may have problems producing results, because the model itself may fail to fullfill certain estimation criterias.\n   When that happens, one option is to add `noestimcheck` and/or `force` option. \n3. Some models rely on analytical solutions based on the chainrule. While this may not be a problem in the latest `f_able` update (auto option), it could still linger for some models. When this happens, try option `nochainrule`.\n4. Some times, no results will be shown because the variance covariance matrix is not symetric. This happens because of the small discrepancies produced by the numerical differentiation. If something like that appears, there are two utilities `f_symev` and `f_symrv`, that will fix it before you produce the necessary results again.\n\nHope you find it useful.\n\n",
    "supporting": [
      "stata_do6_files\\figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}