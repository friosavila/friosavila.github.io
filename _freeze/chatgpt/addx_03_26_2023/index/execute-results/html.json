{
  "hash": "622ab57a38ddb52dc8fd21fd9033810d",
  "result": {
    "markdown": "---\ntitle: \"Adding info to e() and r()\"\ndescription: \"I describe and introduce the programs `adde` and `addr`. They allow you to add and modify information to some Stata Objects\"\nauthor: \"Fernando Rios-Avila\"\ndate: \"3/25/2023\"\ncategories: \n    - Stata\n    - Programming\ndraft: false\n---\n\n## First the basics\n\n::: {.cell execution_count=1}\n\n::: {.cell-output .cell-output-stdout}\n```\n(1978 automobile data)\n```\n:::\n:::\n\n\nAs you may know, whenever `Stata` runs calculations, it stores the information created in *elements* that can be easily accessed in subsequent commands. \n\nWhile most standard users will not require to know how to manipulate this information, if you are trying to advances your programming skills, it will be necessary for you to learn what type of information can be contained in this elements, and how to modify them. A good place to start learning about them is by typing `help return`.\n\nOverall, there are three types of elements:\n\nr-class: These elements are produced by non-estimation commands. For example, after `summarize`, you can see what information is stored by the command by typing `return list`. They can store locals, scalars and matrices.\n\n::: {.cell execution_count=2}\n\n::: {.cell-output .cell-output-stdout}\n```\n\n. summarize mpg\n\n    Variable |        Obs        Mean    Std. dev.       Min        Max\n-------------+---------------------------------------------------------\n         mpg |         74     21.2973    5.785503         12         41\n\n. return list\n\nscalars:\n                  r(N) =  74\n              r(sum_w) =  74\n               r(mean) =  21.2972972972973\n                r(Var) =  33.47204738985561\n                 r(sd) =  5.785503209735141\n                r(min) =  12\n                r(max) =  41\n                r(sum) =  1576\n\n. \n```\n:::\n:::\n\n\ne-class: These elements are typically produced after estimation commands. At the minimum, it will contain information of estimated coefficients, variance covariance matrix, and the estimation command that was used. To see the information left behind, you just need to type `ereturn list`. They can store locals, scalars and matrices.\n\n::: {.cell execution_count=3}\n``` {.stata .cell-code code-fold=\"false\"}\nqui:reg price mpg\nereturn list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nscalars:\n                  e(N) =  74\n               e(df_m) =  1\n               e(df_r) =  72\n                  e(F) =  20.25835256291882\n                 e(r2) =  .2195828561874973\n               e(rmse) =  2623.652888667587\n                e(mss) =  139449473.54623\n                e(rss) =  495615922.5753916\n               e(r2_a) =  .2087437291901014\n                 e(ll) =  -686.5395809065244\n               e(ll_0) =  -695.7128688987767\n               e(rank) =  2\n\nmacros:\n            e(cmdline) : \"regress price mpg\"\n              e(title) : \"Linear regression\"\n          e(marginsok) : \"XB default\"\n                e(vce) : \"ols\"\n             e(depvar) : \"price\"\n                e(cmd) : \"regress\"\n         e(properties) : \"b V\"\n            e(predict) : \"regres_p\"\n              e(model) : \"ols\"\n          e(estat_cmd) : \"regress_estat\"\n\nmatrices:\n                  e(b) :  1 x 2\n                  e(V) :  2 x 2\n               e(beta) :  1 x 1\n\nfunctions:\n             e(sample)   \n```\n:::\n:::\n\n\ns-class: These elements are used to help with parsing. They can only store locals.\n\n## Adding elements to e() and r()\n\nWhile creating and modifying this information from within your own programs is easy, some times, you may want to add additional information to your summary statistics, or your regression results. You may also want to create a set of results from scracth, but being able to store it in equation form.\n\nWell, to do this, you can use the programs [`adde`](adde.ado) and [`addr`](addr.ado). Both programs have the goal of adding or modifying information to e() and r(). They structures are rather simple:\n\n::: {.cell execution_count=4}\n``` {.stata .cell-code code-fold=\"false\" code-line-numbers=\"true\"}\nprogram adde, eclass\n    ereturn `0'\nend\n\nprogram addr, rclass\n\tsyntax anything(equalok), [new copy]\n\tif \"`new'\"==\"\" {\n\t\treturn add\n\t\tif \"`copy'\"!=\"\"\tlocal 0 `anything', copy\n\t\telse \t\t\tlocal 0 `anything'\n\t}\n\telse {\n\t    if \"`copy'\"!=\"\"\tlocal 0 `anything', copy\n\t\telse \t\t\tlocal 0 `anything'\n\t}\n\treturn `0'\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n:::\n\n\nBecause examples are usally better than words, here a very small example:\n\nFirst using `adde`:\n\n::: {.cell execution_count=5}\n``` {.stata .cell-code code-fold=\"false\"}\nqui:reg price mpg\nadde local note \"Regression MPG vs Price\"\nadde local data \"auto.dta\"\nereturn list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nscalars:\n                  e(N) =  74\n               e(df_m) =  1\n               e(df_r) =  72\n                  e(F) =  20.25835256291882\n                 e(r2) =  .2195828561874973\n               e(rmse) =  2623.652888667587\n                e(mss) =  139449473.54623\n                e(rss) =  495615922.5753916\n               e(r2_a) =  .2087437291901014\n                 e(ll) =  -686.5395809065244\n               e(ll_0) =  -695.7128688987767\n               e(rank) =  2\n\nmacros:\n               e(data) : \"auto.dta\"\n               e(note) : \"Regression MPG vs Price\"\n            e(cmdline) : \"regress price mpg\"\n              e(title) : \"Linear regression\"\n          e(marginsok) : \"XB default\"\n                e(vce) : \"ols\"\n             e(depvar) : \"price\"\n                e(cmd) : \"regress\"\n         e(properties) : \"b V\"\n            e(predict) : \"regres_p\"\n              e(model) : \"ols\"\n          e(estat_cmd) : \"regress_estat\"\n\nmatrices:\n                  e(b) :  1 x 2\n                  e(V) :  2 x 2\n               e(beta) :  1 x 1\n\nfunctions:\n             e(sample)   \n```\n:::\n:::\n\n\nBut also with `addr`:\n\n::: {.cell execution_count=6}\n``` {.stata .cell-code code-fold=\"false\"}\nqui:sum price \naddr local note \"Summary of Price\"\naddr scalar magic = 1\nreturn list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nscalars:\n              r(magic) =  1\n                r(sum) =  456229\n                r(max) =  15906\n                r(min) =  3291\n                 r(sd) =  2949.495884768919\n                r(Var) =  8699525.974268788\n               r(mean) =  6165.256756756757\n              r(sum_w) =  74\n                  r(N) =  74\n\nmacros:\n               r(note) : \"Summary of Price\"\n```\n:::\n:::\n\n\n## Installation\n\nTo install this programs, simply create ado files with the names `addr.ado` and `adde.ado`, and save them in your personal ado folder. otherwise, just copy the versions I provide you here: [`adde`](adde.ado) and [`addr`](addr.ado)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}