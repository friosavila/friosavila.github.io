<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.45">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>DID: The Revolution – Playing With Stata</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../app_metrics/app_metrics5.html" rel="next">
<link href="../app_metrics/app_metrics3.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-GNMLZDYJ2P"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-GNMLZDYJ2P', { 'anonymize_ip': true});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>



<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Playing With Stata</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../cv.html"> 
<span class="menu-text">my CV and Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../software.html"> 
<span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../stataviz/index.html"> 
<span class="menu-text">Stata Viz</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../stata_do/index.html"> 
<span class="menu-text">Stata Do’s Ado’s</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../app_metrics/index.html"> 
<span class="menu-text">Applied econometrics</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../chatgpt.html"> 
<span class="menu-text">Odds and Ends</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">about</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../app_metrics/app_metrics1.html">App Metrics</a></li><li class="breadcrumb-item"><a href="../app_metrics/app_metrics4.html">DID: The Revolution</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../index.html" class="sidebar-logo-link">
      <img src="../WeeMee.jpg" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../app_metrics/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Applied Econometrics</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">App Metrics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../app_metrics/app_metrics1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Constructing synthetic Datasets</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../app_metrics/app_metrics10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Nonlinear DID</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../app_metrics/app_metrics11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><strong><code>jwdid</code></strong>: A Stata command for the estimation of Difference-in-Differences models using ETWFE</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../app_metrics/app_metrics2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DRDID/CSDID in Stata</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../app_metrics/app_metrics3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DID: The Fall</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../app_metrics/app_metrics4.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">DID: The Revolution</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../app_metrics/app_metrics5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2x2 DID: Sant’Anna and Zhao (2020)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../app_metrics/app_metrics6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Making better use of interval-censored data</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../app_metrics/app_metrics7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Linear Regressions, OLS and Standard Errors</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../app_metrics/app_metrics8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DID: Panel Data &amp; Repeated Crossection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../app_metrics/app_metrics9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Quantile regressions with multiple fixed effects</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#solutions" id="toc-solutions" class="nav-link" data-scroll-target="#solutions">Solutions</a>
  <ul class="collapse">
  <li><a href="#setup" id="toc-setup" class="nav-link" data-scroll-target="#setup">Setup</a></li>
  <li><a href="#two-steps-did" id="toc-two-steps-did" class="nav-link" data-scroll-target="#two-steps-did">Two-Steps DID</a></li>
  <li><a href="#you-dont-messup-with-ols" id="toc-you-dont-messup-with-ols" class="nav-link" data-scroll-target="#you-dont-messup-with-ols">You don’t messup with OLS</a></li>
  <li><a href="#x2-on-steroids" id="toc-x2-on-steroids" class="nav-link" data-scroll-target="#x2-on-steroids">2x2 on Steroids</a></li>
  </ul></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../app_metrics/app_metrics1.html">App Metrics</a></li><li class="breadcrumb-item"><a href="../app_metrics/app_metrics4.html">DID: The Revolution</a></li></ol></nav>
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">DID: The Revolution</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
<p class="subtitle lead">How to right the wrongs</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>If you have been keeping up with the advancements and revolution in Difference-in-Differences (DID), you may be aware of the issues associated with using the simple Two-Way Fixed Effects (TWFE) method for identifying treatment effects. If you haven’t, you can refer to my previous post titled <strong>DID: The fall</strong> where I have explained the problem.</p>
<p>The issue can be summarized as follows:</p>
<p>When multiple periods and groups are available, and the treatment has been implemented over several periods, the standard TWFE method is unlikely to identify the average treatment effects. This is because it tends to use inadequate controls, gives negative weights to treated units, and generally suffers from contamination that leads to biased estimates.</p>
<p>As far as I know, the following model can only estimate average treatment effects if treatment effects remain constant over time: <span class="math display">\[
y_{it} = a_i + a_t + \delta D_{it} + e_{it}
\]</span></p>
<p>where <span class="math inline">\(D_{it}=1\)</span> if a unit is effectively treated, <span class="math inline">\(a_i\)</span> represents the unit fixed effects, and <span class="math inline">\(a_t\)</span> time fixed effects.</p>
</section>
<section id="solutions" class="level2">
<h2 class="anchored" data-anchor-id="solutions">Solutions</h2>
<p>Despite the challenges previously discussed, there is still hope for the successful implementation of DID. Numerous scholars have proposed various strategies that specifically address the issues at hand, as hinted in <strong>DID: the Fall.</strong></p>
<p>In this context, I will provide a brief overview of three such solutions, two of which I am actively involved in, and one that is relatively straightforward to comprehend and articulate.</p>
<section id="setup" class="level3">
<h3 class="anchored" data-anchor-id="setup">Setup</h3>
<p>Let us establish some fundamental nomenclature before we delve into the solution. This terminology will help understand and implement the solutions we will cover next.</p>
<p>Before we start discussing the solution, lets stablish some basic nomenclature that may help us understand and implement the solutions we will be discussing later on.</p>
<ol type="1">
<li><p>For simplicity, we will focus on the case of balanced panel data. All units <span class="math inline">\(i\)</span> will be observed for <span class="math inline">\(T\)</span> periods, from <span class="math inline">\(t=1\)</span> to <span class="math inline">\(t=T\)</span>.</p></li>
<li><p>At any given time, individual outcomes are defined as follows: <span class="math display">\[
y_{it} = a_i + a_t + \delta_{it}*D_{it} +e_{it}
\]</span></p></li>
</ol>
<p>where <span class="math inline">\(a_i\)</span> is the individual fixed effect, <span class="math inline">\(a_t\)</span> is a time fixed effect, and <span class="math inline">\(e_{it}\)</span> is an individual level iid error. <span class="math inline">\(D_{it}\)</span> is a dummy variable that takes the value of 1 after a unit is treated.</p>
<p>Notice that here, the treatment effect fully heterogeneous.</p>
<ol start="3" type="1">
<li><p>Once a unit has been treated, it remains so, even if the effect eventually fades away. (if <span class="math inline">\(D_{it}=1 \rightarrow D_{is}=1 \ \forall \ s&gt;t\)</span>)</p></li>
<li><p>There is variation in treatment timing, and as a result, the treatment dummy is not activated for everyone at the same time.</p></li>
<li><p>Assume there are no controls.</p></li>
</ol>
<p>Under this conditions, lets simulate a simple dataset with this characteristics:</p>
<div id="c9c2937e" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">clear</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> <span class="dv">linesize</span> 250</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> <span class="dv">seed</span>     111</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> sortseed 111</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> <span class="kw">obs</span> 100  <span class="co">// &lt;- 100 units</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">gen</span> id = <span class="dt">_n</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">gen</span> ai = rchi2(2)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">// determines When would units receive treatment</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">gen</span>     g = runiformint(2,10)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">replace</span> g = 0 <span class="kw">if</span> g&gt;9   <span class="co">// never treated       </span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>expand 10   <span class="co">// &lt;-T=10</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">bysort</span> id:<span class="kw">gen</span> t=<span class="dt">_n</span> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">gen</span> event = <span class="fu">max</span>(0,t-g)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">gen</span> aux = runiform()*2</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">bysort</span> t:<span class="kw">gen</span> <span class="fu">at</span> = aux[1] <span class="co">// Determines Time fixed effect</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">gen</span> <span class="kw">te</span> = (1-g/10)+(1-event/10)  </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Treatment effect but vanishes with time</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">gen</span> eit= rnormal()</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">gen</span> trt  = (t&gt;=g)*(g&gt;0)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">gen</span> teff = <span class="kw">te</span> * trt </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="kw">gen</span> <span class="fu">y</span> = ai + <span class="fu">at</span> + <span class="kw">te</span> * trt + eit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<style>div.jp-Notebook .datagrid-container {min-height: 448px; }</style>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Number of observations (_N) was 0, now 100.
(18 real changes made)
(900 observations created)</code></pre>
</div>
</div>
<p>The simulated data will follow 100 units over a span of 10 periods. Each unit is assigned to receive treatment at some point between periods 2 and 9, while 1/10 of the sample is not treated at all.</p>
<p>The impact of the treatment depends on two factors: the timing of treatment and the duration of treatment. The treatment effect becomes smaller the later a unit is treated, and as a unit is treated for longer durations.</p>
</section>
<section id="two-steps-did" class="level3">
<h3 class="anchored" data-anchor-id="two-steps-did">Two-Steps DID</h3>
<section id="gardner_two-stage_2022-did2s-borusyak_revisiting_2022-did_imputation" class="level4">
<h4 class="anchored" data-anchor-id="gardner_two-stage_2022-did2s-borusyak_revisiting_2022-did_imputation"><span class="citation" data-cites="gardner_two-stage_2022">Gardner (<a href="#ref-gardner_two-stage_2022" role="doc-biblioref">2022</a>)</span> <code>did2s</code> &amp; <span class="citation" data-cites="borusyak_revisiting_2022">Borusyak, Jaravel, and Spiess (<a href="#ref-borusyak_revisiting_2022" role="doc-biblioref">2022</a>)</span> <code>did_imputation</code></h4>
<p>Let’s start by desribing one of the solutions solutions: the two-step DID, also referred to as the imputation approach. This strategy is explained and explored by two notable papers: <span class="citation" data-cites="gardner_two-stage_2022">Gardner (<a href="#ref-gardner_two-stage_2022" role="doc-biblioref">2022</a>)</span> and <span class="citation" data-cites="borusyak_revisiting_2022">Borusyak, Jaravel, and Spiess (<a href="#ref-borusyak_revisiting_2022" role="doc-biblioref">2022</a>)</span>.</p>
<p>As the name implies, this approach aims to estimate treatment effects in a design with multiple groups treated at various points in time by imputing the values of what would have occurred to those units if they were never subjected to treatment. To accomplish this, the authors suggest breaking down the identification problem into two steps to avoid the erroneous use of already treated units as controls.</p>
<p>In the first step, one should only use units that have never been treated or have not yet been treated to model potential outcomes under the no-treatment scenario.</p>
<p><span class="math display">\[
y_{it} = a_i + a_t + e_{it} \ if \ t&lt;g
\]</span></p>
<p>Doing this, the fixed effects <span class="math inline">\(a_i\)</span> and <span class="math inline">\(a_t\)</span> would not be contaminated by the treatment, because non of the units in the sample are treated.</p>
<p>In the second step, individual-level treatment effects predictions can be obtained by simply computing the difference between the observed outcome under treatment and the prediction of the first step (<span class="math inline">\(\hat y_{it} = \hat a_i + \hat a _t\)</span>), which represent the potential outcomes of those units if no treatment occured.</p>
<p><span class="math display">\[
\delta_{it} = y_{it}-\hat a_i - \hat a_t
\]</span></p>
<p>Because unit level treatment effects are not useful for statistical inference, one can use aggregations to obtain standard errors or aggregates we are more familiar with: Average treatment effect on treated, dynamic effects, etc.</p>
<p>To correctly estimate standard errors, both steps should be estimated simulatenously, so that the estimation error from the first stage can propagate to the second stage. While you can use <code>did2s</code> or <code>did_imputation</code>, I will show you the code using <code>gmm</code>, so you can see how the whole system would work.</p>
<p>In the following code line (1) identifies the individual and time FE using only notyet treated units (trt=0). Line 2 uses tha to substract from <span class="math inline">\(y\)</span> and identify the treatment effect (ATT). Lines 3 and 4 provides information to gmm to estimate the model and standard errors:</p>
<div id="6374f8ef" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>gmm ((<span class="fu">y</span>-{a0}-{a_i:i.g}-{a_t:i.t})*(trt==0))     <span class="co">/// </span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    ((<span class="fu">y</span>-{a0}-{a_i:}   -{a_t:}    -{att:trt})) , <span class="co">/// </span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    winitial(<span class="kw">identity</span>)  instruments(1:i.g i.t) instruments(2: trt) <span class="co">/// </span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    onestep quickderivatives <span class="kw">vce</span>(<span class="kw">cluster</span> i)  </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Step 1
Iteration 0:   GMM criterion Q(b) =  19.725543  
Iteration 1:   GMM criterion Q(b) =  5.816e-23  
Iteration 2:   GMM criterion Q(b) =  9.081e-33  

GMM estimation 

Number of parameters =  19
Number of moments    =  20
Initial weight matrix: Identity                   Number of obs   =      1,000

                                   (Std. err. adjusted for 100 clusters in id)
------------------------------------------------------------------------------
             |               Robust
             | Coefficient  std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
a0           |
       _cons |   3.146414   .6822892     4.61   0.000     1.809152    4.483677
-------------+----------------------------------------------------------------
a_i          |
           g |
          2  |  -1.329894   .9540798    -1.39   0.163    -3.199856    .5400685
          3  |   .3303121   .9832247     0.34   0.737    -1.596773    2.257397
          4  |  -.9533545   .8233816    -1.16   0.247    -2.567153    .6604439
          5  |  -.9570973   .8366389    -1.14   0.253    -2.596879    .6826848
          6  |    -.58129   .8707363    -0.67   0.504    -2.287902    1.125322
          7  |   .9916895   1.010794     0.98   0.327    -.9894297    2.972809
          8  |  -1.609291   .7437976    -2.16   0.030    -3.067108   -.1514746
          9  |  -1.160353   1.033179    -1.12   0.261    -3.185346    .8646411
-------------+----------------------------------------------------------------
a_t          |
           t |
          2  |  -.0585438   .1385197    -0.42   0.673    -.3300374    .2129498
          3  |   -.213678   .1704212    -1.25   0.210    -.5476975    .1203415
          4  |  -.5752045   .1713895    -3.36   0.001    -.9111217   -.2392872
          5  |   .0842171   .1677747     0.50   0.616    -.2446152    .4130494
          6  |   .1190078   .1841714     0.65   0.518    -.2419615    .4799771
          7  |   1.000738   .2034229     4.92   0.000     .6020363    1.399439
          8  |  -.0146057   .2190799    -0.07   0.947    -.4439945    .4147831
          9  |   .9380065   .2007013     4.67   0.000     .5446391    1.331374
         10  |   .9572597   .2578496     3.71   0.000     .4518838    1.462636
-------------+----------------------------------------------------------------
att          |
         trt |   1.458058   .1493165     9.76   0.000     1.165403    1.750713
------------------------------------------------------------------------------
Instruments for equation 1: 0b.g 2.g 3.g 4.g 5.g 6.g 7.g 8.g 9.g 1b.t 2.t 3.t 4.t 5.t 6.t 7.t 8.t 9.t 10.t _cons
Instruments for equation 2: trt _cons</code></pre>
</div>
</div>
<p>You can compare this to the true effect:</p>
<div id="b3afbba1" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">sum</span> teff <span class="kw">if</span> trt==1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
        teff |        472    1.280297    .2217799          1        1.8</code></pre>
</div>
</div>
<p>One advantage of this approach is that you could model the second stage to allow other types of aggregations:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">gen</span> g0=g*trt    </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">gen</span> t0=t*trt</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>gmm ((<span class="fu">y</span>-{a0}-{a_i:i.g}-{a_t:i.t})*(trt==0)) <span class="co">///</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    ((<span class="fu">y</span>-{a0}-{a_i:}   -{a_t:}    -{att:i.g0})) , <span class="co">///</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    winitial(<span class="kw">identity</span>)  instruments(1:i.g i.t) instruments(1: i.g0) <span class="co">///</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    onestep quickderivatives <span class="kw">vce</span>(<span class="kw">cluster</span> i) </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>gmm ((<span class="fu">y</span>-{a0}-{a_i:i.g}-{a_t:i.t})*(trt==0)) <span class="co">///</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    ((<span class="fu">y</span>-{a0}-{a_i:}   -{a_t:}    -{att:i.t0})) , <span class="co">///</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    winitial(<span class="kw">identity</span>)  instruments(1:i.g i.t) instruments(2: i.t0) <span class="co">///</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    onestep quickderivatives <span class="kw">vce</span>(<span class="kw">cluster</span> i)             </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="you-dont-messup-with-ols" class="level3">
<h3 class="anchored" data-anchor-id="you-dont-messup-with-ols">You don’t messup with OLS</h3>
<section id="wooldridge_twoway_2021-jwdid-and-sun_estimating_2021" class="level4">
<h4 class="anchored" data-anchor-id="wooldridge_twoway_2021-jwdid-and-sun_estimating_2021"><span class="citation" data-cites="wooldridge_twoway_2021">Wooldridge (<a href="#ref-wooldridge_twoway_2021" role="doc-biblioref">2021</a>)</span> <code>jwdid</code> and <span class="citation" data-cites="sun_estimating_2021">Sun and Abraham (<a href="#ref-sun_estimating_2021" role="doc-biblioref">2021</a>)</span></h4>
<p>In the article <strong>DID: the fall</strong>, it was pointed out that the conventional TWFE approach has faced significant backlash due to its limited ability to detect treatment effects, because it cannot distinguish between good and bad variation when estimating treatment effects. Despite this criticism, Professor Wooldridge came in defense and revitalized the approach by emphasizing its simplicity and versatility, enabling extensions to go beyond linear models.</p>
<p>The message was simple:</p>
<blockquote class="blockquote">
<p>Although the conventional TWFE method has several shortcomings, if it is implemented correctly, it can overcome the issue of utilizing inadequate controls in estimation. As a result, it can estimate treatment effects efficiently, with results similar to <span class="citation" data-cites="borusyak_revisiting_2022">Borusyak, Jaravel, and Spiess (<a href="#ref-borusyak_revisiting_2022" role="doc-biblioref">2022</a>)</span> and <span class="citation" data-cites="gardner_two-stage_2022">Gardner (<a href="#ref-gardner_two-stage_2022" role="doc-biblioref">2022</a>)</span>.</p>
</blockquote>
<p>So what were we missing? Heterogeneity!</p>
<p>Both <span class="citation" data-cites="wooldridge_twoway_2021">Wooldridge (<a href="#ref-wooldridge_twoway_2021" role="doc-biblioref">2021</a>)</span> and <span class="citation" data-cites="sun_estimating_2021">Sun and Abraham (<a href="#ref-sun_estimating_2021" role="doc-biblioref">2021</a>)</span> have proposed similar solutions to the problem at hand, albeit from different viewpoints. <span class="citation" data-cites="sun_estimating_2021">Sun and Abraham (<a href="#ref-sun_estimating_2021" role="doc-biblioref">2021</a>)</span> argued that utilizing event studies with leads and lags may lead to contaminated coefficients, thus hampering proper identification of dynamic treatment effects. As a potential solution, the authors suggests using a specification that estimates dynamic effects for each cohort before making aggregations.</p>
<p>On the other hand, <span class="citation" data-cites="wooldridge_twoway_2021">Wooldridge (<a href="#ref-wooldridge_twoway_2021" role="doc-biblioref">2021</a>)</span> focused on identifying treatment effects. He recommends allowing all treatment effects to vary by cohort and time. In other words, instead of employing a single dummy variable to identify treated units, he suggests using a set of dummies representing the interaction of cohorts and periods.</p>
<p>Specifically, <span class="citation" data-cites="wooldridge_twoway_2021">Wooldridge (<a href="#ref-wooldridge_twoway_2021" role="doc-biblioref">2021</a>)</span> proposes estimating a model with the following specification:</p>
<p><span class="math display">\[
y_{it} = a_i + a_t + \sum_{g=g_0}^G \sum_{t=g}^T \delta_{gt} * 1(g,t)+e_{it}
\]</span></p>
<p>What Wooldridge suggests, at least for the case without covariates, is to estimate a model where, in addition to the individual (or cohort) and time fixed effects, we saturate <strong>all</strong> possible combinations of cohorts and times (<span class="math inline">\(1(g,t)\)</span>), if that combination corresponds to an effectively treated unit (<span class="math inline">\(t\geq g\)</span>). This specification essentially uses all not-yet treated units as controls, similar to the two-step approach.</p>
<p>This specification, however, could also be extended to a case where only those never treated are used as controls. In this case, one should use all cohort and time interactions, including the cases before units were treated. Following convention, one should exclude from the list of interactions the period before treatment took place:</p>
<p><span class="math display">\[
y_{it} = a_i + a_t + \sum_{g=g_0}^G \sum_{t\neq g-1} \delta_{gt} * 1(g,t)+e_{it}
\]</span></p>
<p>By saturating the model this way, each <span class="math inline">\(\delta_{gt}\)</span> represents a treatment effect for group G at time T, which can be later aggregated to obtain dynamic, group, or average treatment effects. Also interesting to note that this second specification is essentially the same <span class="citation" data-cites="sun_estimating_2021">Sun and Abraham (<a href="#ref-sun_estimating_2021" role="doc-biblioref">2021</a>)</span> propose for dynamic effects, and produces results that are identical to the methodology proposed by <span class="citation" data-cites="callaway_santanna_2021">Callaway and Sant’Anna (<a href="#ref-callaway_santanna_2021" role="doc-biblioref">2021</a>)</span>.</p>
<p>Now for the application, I will use <code>jwdid</code> for both specifications. Because by default <code>jwdid</code> produces the fully saturated model, I will omit those results, showing only the average treatment effect.</p>
<p>First the one using not-yet treated units as controls (default), which produces exactly the same results as the two-step approach:</p>
<div id="ee75df72" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>*<span class="kw">ssc</span> install jwdid</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">qui</span>: jwdid <span class="fu">y</span>, ivar(i) tvar(t) gvar(g)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">estat</span> simple</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>WARNING: Singleton observations not dropped; statistical significance is biased (link)
------------------------------------------------------------------------------
             |            Delta-method
             | Coefficient  std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
      simple |   1.458058   .1494798     9.75   0.000     1.165083    1.751033
------------------------------------------------------------------------------</code></pre>
</div>
</div>
<p>Second the one with never treated units as controls:</p>
<div id="9dd6acd3" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">qui</span>: jwdid <span class="fu">y</span>, ivar(i) tvar(t) gvar(g) never</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">estat</span> simple</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>WARNING: Singleton observations not dropped; statistical significance is biased (link)
------------------------------------------------------------------------------
             |            Delta-method
             | Coefficient  std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
      simple |   1.543749   .1567784     9.85   0.000     1.236469    1.851029
------------------------------------------------------------------------------</code></pre>
</div>
</div>
</section>
</section>
<section id="x2-on-steroids" class="level3">
<h3 class="anchored" data-anchor-id="x2-on-steroids">2x2 on Steroids</h3>
<section id="callaway_santanna_2021-csdid-csdid2" class="level4">
<h4 class="anchored" data-anchor-id="callaway_santanna_2021-csdid-csdid2"><span class="citation" data-cites="callaway_santanna_2021">Callaway and Sant’Anna (<a href="#ref-callaway_santanna_2021" role="doc-biblioref">2021</a>)</span> <code>csdid</code> &amp; <code>csdid2</code></h4>
<p>The third option is the most computing intensive, but at the same time simpler to understand, if you break it down to the basics. This is why I call this 2x2 in Steroids: <span class="citation" data-cites="callaway_santanna_2021">Callaway and Sant’Anna (<a href="#ref-callaway_santanna_2021" role="doc-biblioref">2021</a>)</span>.</p>
<p>The literature on the 2x2 DID design has been extensively explored and extended, and it appears that most of the criticisms of the TWFE method do not apply to this simple design. Although there are a few technical details to consider while estimating ATT’s, most of the information required can be found in <span class="citation" data-cites="santanna_doubly_2020">Sant’Anna and Zhao (<a href="#ref-santanna_doubly_2020" role="doc-biblioref">2020</a>)</span>. In this work, the authors provide several options for obtaining the best estimate from a simple 2x2 DID design.</p>
<p>Assuming that we know how to execute 2x2 DID correctly (which can be achieved using <code>drdid</code> in Stata), <span class="citation" data-cites="callaway_santanna_2021">Callaway and Sant’Anna (<a href="#ref-callaway_santanna_2021" role="doc-biblioref">2021</a>)</span> propose that we focus on estimating all the good and useful 2x2 DID designs from our data while avoiding incorrect comparisons. These are the building blocks of the methodology, the ATTGTs. This are the average treatment effects on the treated for units treated for the first time in period G, but measured at period T.</p>
<p>This process, however, could be time-consuming and computationally intensive if done manually, as the number of 2x2 designs increases with the number of cohorts and periods available in the data. For example, estimating 50 different ATTs would be necessary with 5 cohorts and 10 periods, and up to 5 separate models need to be estimated for each ATT.</p>
<p>Borrowing from the nomenclature in <span class="citation" data-cites="callaway_santanna_2021">Callaway and Sant’Anna (<a href="#ref-callaway_santanna_2021" role="doc-biblioref">2021</a>)</span>, this ATTGT’s are defined as follows: <span class="math display">\[
\begin{aligned}
    ATT(g,t) &amp;= E(Y_{i,t}|i\in g) - E(Y_{i,g-1}|i\in g) \\
             &amp; -\Big[ E(Y_{i,t}|i\in C) - E(Y_{i,g-1}|i\in C) \Big]
\end{aligned}
\]</span></p>
<p>Which has the same structure as the simple 2x2 DID, with the difference that the control group <span class="math inline">\(C\)</span> will be formed by never treated units only, or include those not yet treated ( <span class="math inline">\(i \in g_i, g_i&gt;t, \And \  g_i&gt;g\)</span>).<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>Once all individual ATTGT’s have been identified and estimated, providing summary measures we are more familiar with is as easy as obtaining weighted averages:</p>
<p><span class="math display">\[
SATT = \sum \left( \frac{w_{gt} }{\sum w_{gt}}ATT(g,t) \right)
\]</span></p>
<p>where the weights <span class="math inline">\(w_{gt}\)</span> will change based on the type of aggregation one is interested in.</p>
<p>This multiple stage process may seem challening, but there are tools that allow you to implement them quite easily: <code>csdid</code> and <code>csdid2</code>. The first one, was written as a wrapper around <code>drdid</code>, to do all the heavy lifting for you. However, for large projects, it can be slow due to overhead. The alternative <code>csdid2</code> is self contained, still under development, but much faster than the predecesor. See <a href="https://github.com/friosavila/csdid2"><code>csdid2</code></a> if interested. Here I will use <code>csdid</code>, which you can get from SSC.</p>
<p>As with <code>jwdid</code>. The default option is for <code>csdid</code> to produce all ATTGT’s. So, for the excercise, I’ll omit that ouput, and estimate the aggregate effects with the post estimation command. The default is to use the never treated as controls. I will also add the option <code>long2</code> to obtain the pre-treatment ATTGT’s as describe above, even though they won’t affect our point estimates:</p>
<div id="345b9c68" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">qui</span>: <span class="kw">ssc</span> install drdid, <span class="kw">replace</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">qui</span>: <span class="kw">ssc</span> install csdid, <span class="kw">replace</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">qui</span>: csdid <span class="fu">y</span>, ivar(i) time(t) gvar(g) long2</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">estat</span> simple </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Average Treatment Effect on Treated
------------------------------------------------------------------------------
             | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
         ATT |   1.543749   .1577366     9.79   0.000     1.234591    1.852907
------------------------------------------------------------------------------</code></pre>
</div>
</div>
<p>I will also use the not yet treated, to compare results.</p>
<div id="967d663f" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">qui</span>: csdid <span class="fu">y</span>, ivar(i) time(t) gvar(g) notyet long2</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">estat</span> simple </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Average Treatment Effect on Treated
------------------------------------------------------------------------------
             | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
         ATT |   1.494475   .1587386     9.41   0.000     1.183353    1.805597
------------------------------------------------------------------------------</code></pre>
</div>
</div>
</section>
</section>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<p>On this occasion, I have shared with you three solutions from the literature that aim to overcome the limitations of TWFE. Although there are other solutions available, I personally find these three to be the most intuitive and have worked on them. Granted, I have some bias on the matter.</p>
<p>Despite their apparent differences, these solutions actually converge towards similar outcomes, with discrepancies arising from variations in assumptions regarding control groups or covariate management.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>command</th>
<th>eq command</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>jwdid</code></td>
<td><code>did2s</code> &amp; <code>did_imputation</code></td>
</tr>
<tr class="even">
<td><code>jwdid, never</code></td>
<td><code>eventstudyinteract</code></td>
</tr>
<tr class="odd">
<td><code>jwdid, never</code></td>
<td><code>csdid, long2</code> or <code>csdid2, long</code></td>
</tr>
</tbody>
</table>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-borusyak_revisiting_2022" class="csl-entry" role="listitem">
Borusyak, Kirill, Xavier Jaravel, and Jann Spiess. 2022. <span>“Revisiting <span>Event</span> <span>Study</span> <span>Designs</span>: <span>Robust</span> and <span>Efficient</span> <span>Estimation</span>.”</span> arXiv. <a href="https://doi.org/10.48550/arXiv.2108.12419">https://doi.org/10.48550/arXiv.2108.12419</a>.
</div>
<div id="ref-callaway_santanna_2021" class="csl-entry" role="listitem">
Callaway, Brantly, and Pedro H. C. Sant’Anna. 2021. <span>“Difference-in-<span>Differences</span> with Multiple Time Periods.”</span> <em>Journal of Econometrics</em>, Themed <span>Issue</span>: <span>Treatment</span> <span>Effect</span> 1, 225 (2): 200–230. <a href="https://doi.org/10.1016/j.jeconom.2020.12.001">https://doi.org/10.1016/j.jeconom.2020.12.001</a>.
</div>
<div id="ref-gardner_two-stage_2022" class="csl-entry" role="listitem">
Gardner, John. 2022. <span>“Two-Stage Differences in Differences.”</span> arXiv. <a href="https://doi.org/10.48550/arXiv.2207.05943">https://doi.org/10.48550/arXiv.2207.05943</a>.
</div>
<div id="ref-santanna_doubly_2020" class="csl-entry" role="listitem">
Sant’Anna, Pedro H. C., and Jun Zhao. 2020. <span>“Doubly Robust Difference-in-Differences Estimators.”</span> <em>Journal of Econometrics</em> 219 (1): 101–22. <a href="https://doi.org/10.1016/j.jeconom.2020.06.003">https://doi.org/10.1016/j.jeconom.2020.06.003</a>.
</div>
<div id="ref-sun_estimating_2021" class="csl-entry" role="listitem">
Sun, Liyang, and Sarah Abraham. 2021. <span>“Estimating Dynamic Treatment Effects in Event Studies with Heterogeneous Treatment Effects.”</span> <em>Journal of Econometrics</em>, Themed <span>Issue</span>: <span>Treatment</span> <span>Effect</span> 1, 225 (2): 175–99. <a href="https://doi.org/10.1016/j.jeconom.2020.09.006">https://doi.org/10.1016/j.jeconom.2020.09.006</a>.
</div>
<div id="ref-wooldridge_twoway_2021" class="csl-entry" role="listitem">
Wooldridge, Jeffrey M. 2021. <span>“Two-<span>Way</span> <span>Fixed</span> <span>Effects</span>, the <span>Two</span>-<span>Way</span> <span>Mundlak</span> <span>Regression</span>, and <span>Difference</span>-in-<span>Differences</span> <span>Estimators</span>.”</span> {SSRN} {Scholarly} {Paper}. Rochester, NY. <a href="https://doi.org/10.2139/ssrn.3906345">https://doi.org/10.2139/ssrn.3906345</a>.
</div>
</div>


<!-- -->

</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>There are two other options, but I will leave them for a different post<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/friosavila\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../app_metrics/app_metrics3.html" class="pagination-link" aria-label="DID: The Fall">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">DID: The Fall</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../app_metrics/app_metrics5.html" class="pagination-link" aria-label="2x2 DID: Sant'Anna and Zhao (2020)">
        <span class="nav-page-text">2x2 DID: Sant’Anna and Zhao (2020)</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb16" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "DID: The Revolution"</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "How to right the wrongs"</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introduction</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>If you have been keeping up with the advancements and revolution in Difference-in-Differences (DID), you may be aware of the issues associated with using the simple Two-Way Fixed Effects (TWFE) method for identifying treatment effects. If you haven't, you can refer to my previous post titled **DID: The fall** where I have explained the problem.</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>The issue can be summarized as follows:</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>When multiple periods and groups are available, and the treatment has been implemented over several periods, the standard TWFE method is unlikely to identify the average treatment effects. This is because it tends to use inadequate controls, gives negative weights to treated units, and generally suffers from contamination that leads to biased estimates.</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>As far as I know, the following model can only estimate average treatment effects if treatment effects remain constant over time:</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>y_{it} = a_i + a_t + \delta D_{it} + e_{it}</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>where $D_{it}=1$ if a unit is effectively treated, $a_i$ represents the unit fixed effects, and $a_t$ time fixed effects.</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="fu">## Solutions</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>Despite the challenges previously discussed, there is still hope for the successful implementation of DID. Numerous scholars have proposed various strategies that specifically address the issues at hand, as hinted in **DID: the Fall.**</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>In this context, I will provide a brief overview of three such solutions, two of which I am actively involved in, and one that is relatively straightforward to comprehend and articulate.</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a><span class="fu">### Setup</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>Let us establish some fundamental nomenclature before we delve into the solution. This terminology will help understand and implement the solutions we will cover next.</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>Before we start discussing the solution, lets stablish some basic nomenclature that may help us understand and implement the solutions we will be discussing later on.</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>For simplicity,  we will focus on the case of balanced panel data. All units $i$ will be observed for $T$ periods, from $t=1$ to $t=T$.</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>At any given time, individual outcomes are defined as follows:</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>y_{it} = a_i + a_t + \delta_{it}*D_{it} +e_{it}</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>where $a_i$ is the individual fixed effect, $a_t$ is a time fixed effect, and $e_{it}$ is an individual level iid error. </span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>$D_{it}$ is a dummy variable that takes the value of 1 after a unit is treated. </span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>Notice that here, the treatment effect fully heterogeneous. </span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Once a unit has been treated, it remains so, even if the effect eventually fades away. (if $D_{it}=1 \rightarrow D_{is}=1 \ \forall \ s&gt;t$)</span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>There is variation in treatment timing, and as a result, the treatment dummy is not activated for everyone at the same time.</span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Assume there are no controls.</span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>Under this conditions, lets simulate a simple dataset with this characteristics:</span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a><span class="in">*| code-fold: false</span></span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a><span class="in">clear</span></span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a><span class="in">set linesize 250</span></span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a><span class="in">set seed     111</span></span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a><span class="in">set sortseed 111</span></span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a><span class="in">set obs 100  // &lt;- 100 units</span></span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a><span class="in">gen id = _n</span></span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a><span class="in">gen ai = rchi2(2)</span></span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a><span class="in">// determines When would units receive treatment</span></span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a><span class="in">gen     g = runiformint(2,10)</span></span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a><span class="in">replace g = 0 if g&gt;9   // never treated       </span></span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a><span class="in">expand 10   // &lt;-T=10</span></span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a><span class="in">bysort id:gen t=_n </span></span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a><span class="in">gen event = max(0,t-g)</span></span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a><span class="in">gen aux = runiform()*2</span></span>
<span id="cb16-72"><a href="#cb16-72" aria-hidden="true" tabindex="-1"></a><span class="in">bysort t:gen at = aux[1] // Determines Time fixed effect</span></span>
<span id="cb16-73"><a href="#cb16-73" aria-hidden="true" tabindex="-1"></a><span class="in">gen te = (1-g/10)+(1-event/10)  </span></span>
<span id="cb16-74"><a href="#cb16-74" aria-hidden="true" tabindex="-1"></a><span class="in">// Treatment effect but vanishes with time</span></span>
<span id="cb16-75"><a href="#cb16-75" aria-hidden="true" tabindex="-1"></a><span class="in">gen eit= rnormal()</span></span>
<span id="cb16-76"><a href="#cb16-76" aria-hidden="true" tabindex="-1"></a><span class="in">gen trt  = (t&gt;=g)*(g&gt;0)</span></span>
<span id="cb16-77"><a href="#cb16-77" aria-hidden="true" tabindex="-1"></a><span class="in">gen teff = te * trt </span></span>
<span id="cb16-78"><a href="#cb16-78" aria-hidden="true" tabindex="-1"></a><span class="in">gen y = ai + at + te * trt + eit</span></span>
<span id="cb16-79"><a href="#cb16-79" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-80"><a href="#cb16-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-81"><a href="#cb16-81" aria-hidden="true" tabindex="-1"></a>The simulated data will follow 100 units over a span of 10 periods. Each unit is assigned to receive treatment at some point between periods 2 and 9, while 1/10 of the sample is not treated at all.</span>
<span id="cb16-82"><a href="#cb16-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-83"><a href="#cb16-83" aria-hidden="true" tabindex="-1"></a>The impact of the treatment depends on two factors: the timing of treatment and the duration of treatment. The treatment effect becomes smaller the later a unit is treated, and as a unit is treated for longer durations.</span>
<span id="cb16-84"><a href="#cb16-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-85"><a href="#cb16-85" aria-hidden="true" tabindex="-1"></a><span class="fu">### Two-Steps DID</span></span>
<span id="cb16-86"><a href="#cb16-86" aria-hidden="true" tabindex="-1"></a><span class="fu">#### @gardner_two-stage_2022 `did2s` &amp;  @borusyak_revisiting_2022 `did_imputation`</span></span>
<span id="cb16-87"><a href="#cb16-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-88"><a href="#cb16-88" aria-hidden="true" tabindex="-1"></a>Let's start by desribing one of the solutions solutions: the two-step DID, also referred to as the imputation approach. This strategy is explained and explored by two notable papers: @gardner_two-stage_2022 and @borusyak_revisiting_2022.</span>
<span id="cb16-89"><a href="#cb16-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-90"><a href="#cb16-90" aria-hidden="true" tabindex="-1"></a>As the name implies, this approach aims to estimate treatment effects in a design with multiple groups treated at various points in time by imputing the values of what would have occurred to those units if they were never subjected to treatment. To accomplish this, the authors suggest breaking down the identification problem into two steps to avoid the erroneous use of already treated units as controls.</span>
<span id="cb16-91"><a href="#cb16-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-92"><a href="#cb16-92" aria-hidden="true" tabindex="-1"></a>In the first step, one should only use units that have never been treated or have not yet been treated to model potential outcomes under the no-treatment scenario.</span>
<span id="cb16-93"><a href="#cb16-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-94"><a href="#cb16-94" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-95"><a href="#cb16-95" aria-hidden="true" tabindex="-1"></a>y_{it} = a_i + a_t + e_{it} \ if \ t&lt;g</span>
<span id="cb16-96"><a href="#cb16-96" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-97"><a href="#cb16-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-98"><a href="#cb16-98" aria-hidden="true" tabindex="-1"></a>Doing this, the fixed effects $a_i$ and $a_t$ would not be contaminated by the treatment, because non of the units in the sample are treated. </span>
<span id="cb16-99"><a href="#cb16-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-100"><a href="#cb16-100" aria-hidden="true" tabindex="-1"></a>In the second step, individual-level treatment effects predictions can be obtained by simply computing the difference between the observed outcome under treatment and the prediction of the  first step ($\hat y_{it} = \hat a_i + \hat a _t$), which represent the potential outcomes of those units if no treatment occured.</span>
<span id="cb16-101"><a href="#cb16-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-102"><a href="#cb16-102" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-103"><a href="#cb16-103" aria-hidden="true" tabindex="-1"></a>\delta_{it} = y_{it}-\hat a_i - \hat a_t</span>
<span id="cb16-104"><a href="#cb16-104" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-105"><a href="#cb16-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-106"><a href="#cb16-106" aria-hidden="true" tabindex="-1"></a>Because unit level treatment effects are not useful for statistical inference, one can use aggregations to obtain standard errors or aggregates we are more familiar with: Average treatment effect on treated, dynamic effects, etc.</span>
<span id="cb16-107"><a href="#cb16-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-108"><a href="#cb16-108" aria-hidden="true" tabindex="-1"></a>To correctly estimate standard errors, both steps should be estimated simulatenously, so that the estimation error from the first stage can propagate to the second stage. While you can use `did2s` or `did_imputation`, I will show you the code using `gmm`, so you can see how the whole system would work.</span>
<span id="cb16-109"><a href="#cb16-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-110"><a href="#cb16-110" aria-hidden="true" tabindex="-1"></a>In the following code line (1) identifies the individual and time FE using only notyet treated units (trt=0). Line 2 uses tha to substract from $y$ and identify the treatment effect (ATT). Lines 3 and 4  provides information to gmm to estimate the model and standard errors:</span>
<span id="cb16-111"><a href="#cb16-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-114"><a href="#cb16-114" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb16-115"><a href="#cb16-115" aria-hidden="true" tabindex="-1"></a>gmm ((y-{a0}-{a_i:i.g}-{a_t:i.t})*(trt==0))     /// </span>
<span id="cb16-116"><a href="#cb16-116" aria-hidden="true" tabindex="-1"></a>    ((y-{a0}-{a_i:}   -{a_t:}    -{att:trt})) , /// </span>
<span id="cb16-117"><a href="#cb16-117" aria-hidden="true" tabindex="-1"></a>    winitial(identity)  instruments(1:i.g i.t) instruments(2: trt) /// </span>
<span id="cb16-118"><a href="#cb16-118" aria-hidden="true" tabindex="-1"></a>    onestep quickderivatives vce(cluster i)  </span>
<span id="cb16-119"><a href="#cb16-119" aria-hidden="true" tabindex="-1"></a>```</span>
<span id="cb16-120"><a href="#cb16-120" aria-hidden="true" tabindex="-1"></a>You can compare this to the true effect:</span>
<span id="cb16-123"><a href="#cb16-123" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb16-124"><a href="#cb16-124" aria-hidden="true" tabindex="-1"></a>sum teff if trt==1</span>
<span id="cb16-125"><a href="#cb16-125" aria-hidden="true" tabindex="-1"></a>```</span>
<span id="cb16-126"><a href="#cb16-126" aria-hidden="true" tabindex="-1"></a>One advantage of this approach is that you could model the second stage to allow other types of aggregations:</span>
<span id="cb16-127"><a href="#cb16-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-128"><a href="#cb16-128" aria-hidden="true" tabindex="-1"></a>```stata</span>
<span id="cb16-129"><a href="#cb16-129" aria-hidden="true" tabindex="-1"></a>gen g0=g*trt    </span>
<span id="cb16-130"><a href="#cb16-130" aria-hidden="true" tabindex="-1"></a>gen t0=t*trt</span>
<span id="cb16-131"><a href="#cb16-131" aria-hidden="true" tabindex="-1"></a>gmm ((y-{a0}-{a_i:i.g}-{a_t:i.t})*(trt==0)) ///</span>
<span id="cb16-132"><a href="#cb16-132" aria-hidden="true" tabindex="-1"></a>    ((y-{a0}-{a_i:}   -{a_t:}    -{att:i.g0})) , ///</span>
<span id="cb16-133"><a href="#cb16-133" aria-hidden="true" tabindex="-1"></a>    winitial(identity)  instruments(1:i.g i.t) instruments(1: i.g0) ///</span>
<span id="cb16-134"><a href="#cb16-134" aria-hidden="true" tabindex="-1"></a>    onestep quickderivatives vce(cluster i) </span>
<span id="cb16-135"><a href="#cb16-135" aria-hidden="true" tabindex="-1"></a>gmm ((y-{a0}-{a_i:i.g}-{a_t:i.t})*(trt==0)) ///</span>
<span id="cb16-136"><a href="#cb16-136" aria-hidden="true" tabindex="-1"></a>    ((y-{a0}-{a_i:}   -{a_t:}    -{att:i.t0})) , ///</span>
<span id="cb16-137"><a href="#cb16-137" aria-hidden="true" tabindex="-1"></a>    winitial(identity)  instruments(1:i.g i.t) instruments(2: i.t0) ///</span>
<span id="cb16-138"><a href="#cb16-138" aria-hidden="true" tabindex="-1"></a>    onestep quickderivatives vce(cluster i)             </span>
<span id="cb16-139"><a href="#cb16-139" aria-hidden="true" tabindex="-1"></a>```    </span>
<span id="cb16-140"><a href="#cb16-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-141"><a href="#cb16-141" aria-hidden="true" tabindex="-1"></a>### You don't messup with OLS</span>
<span id="cb16-142"><a href="#cb16-142" aria-hidden="true" tabindex="-1"></a>#### @wooldridge_twoway_2021 `jwdid` and @sun_estimating_2021</span>
<span id="cb16-143"><a href="#cb16-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-144"><a href="#cb16-144" aria-hidden="true" tabindex="-1"></a>In the article **DID: the fall**, it was pointed out that the conventional TWFE approach has faced significant backlash due to its limited ability to detect treatment effects, because it cannot distinguish between good and bad variation when estimating treatment effects. Despite this criticism, Professor Wooldridge came in defense and revitalized the approach by emphasizing its simplicity and versatility, enabling extensions to go beyond linear models.</span>
<span id="cb16-145"><a href="#cb16-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-146"><a href="#cb16-146" aria-hidden="true" tabindex="-1"></a>The message was simple:</span>
<span id="cb16-147"><a href="#cb16-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-148"><a href="#cb16-148" aria-hidden="true" tabindex="-1"></a>&gt; Although the conventional TWFE method has several shortcomings, if it is implemented correctly, it can overcome the issue of utilizing inadequate controls in estimation. As a result, it can estimate treatment effects efficiently, with results similar to @borusyak_revisiting_2022 and @gardner_two-stage_2022.</span>
<span id="cb16-149"><a href="#cb16-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-150"><a href="#cb16-150" aria-hidden="true" tabindex="-1"></a>So what were we missing? Heterogeneity!</span>
<span id="cb16-151"><a href="#cb16-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-152"><a href="#cb16-152" aria-hidden="true" tabindex="-1"></a>Both @wooldridge_twoway_2021 and @sun_estimating_2021 have proposed similar solutions to the problem at hand, albeit from different viewpoints. @sun_estimating_2021 argued that utilizing event studies with leads and lags may lead to contaminated coefficients, thus hampering proper identification of dynamic treatment effects. As a potential solution, the authors suggests using a specification that estimates dynamic effects for each cohort before making aggregations.</span>
<span id="cb16-153"><a href="#cb16-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-154"><a href="#cb16-154" aria-hidden="true" tabindex="-1"></a>On the other hand, @wooldridge_twoway_2021 focused on identifying treatment effects. He recommends allowing all treatment effects to vary by cohort and time. In other words, instead of employing a single dummy variable to identify treated units, he suggests using a set of dummies representing the interaction of cohorts and periods.</span>
<span id="cb16-155"><a href="#cb16-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-156"><a href="#cb16-156" aria-hidden="true" tabindex="-1"></a>Specifically, @wooldridge_twoway_2021 proposes estimating a model with the following specification:</span>
<span id="cb16-157"><a href="#cb16-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-158"><a href="#cb16-158" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-159"><a href="#cb16-159" aria-hidden="true" tabindex="-1"></a>y_{it} = a_i + a_t + \sum_{g=g_0}^G \sum_{t=g}^T \delta_{gt} * 1(g,t)+e_{it}</span>
<span id="cb16-160"><a href="#cb16-160" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-161"><a href="#cb16-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-162"><a href="#cb16-162" aria-hidden="true" tabindex="-1"></a>What Wooldridge suggests, at least for the case without covariates, is to estimate a model where, in addition to the individual (or cohort) and time fixed effects, we saturate **all** possible combinations of cohorts and times ($1(g,t)$), if that combination corresponds to an effectively treated unit ($t\geq g$). This specification essentially uses all not-yet treated units as controls, similar to the two-step approach.</span>
<span id="cb16-163"><a href="#cb16-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-164"><a href="#cb16-164" aria-hidden="true" tabindex="-1"></a>This specification, however, could also be extended to a case where only those never treated are used as controls. In this case, one should use all cohort and time interactions, including the cases before units were treated. Following convention, one should exclude from the list of interactions the period before treatment took place:</span>
<span id="cb16-165"><a href="#cb16-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-166"><a href="#cb16-166" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-167"><a href="#cb16-167" aria-hidden="true" tabindex="-1"></a>y_{it} = a_i + a_t + \sum_{g=g_0}^G \sum_{t\neq g-1} \delta_{gt} * 1(g,t)+e_{it}</span>
<span id="cb16-168"><a href="#cb16-168" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-169"><a href="#cb16-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-170"><a href="#cb16-170" aria-hidden="true" tabindex="-1"></a>By saturating the model this way, each $\delta_{gt}$ represents a treatment effect for group G at time T, which can be later aggregated to obtain dynamic, group, or average treatment effects. Also interesting to note that this second specification is essentially the same @sun_estimating_2021 propose for dynamic effects, and produces results that are identical to the methodology proposed by @callaway_santanna_2021.</span>
<span id="cb16-171"><a href="#cb16-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-172"><a href="#cb16-172" aria-hidden="true" tabindex="-1"></a>Now for the application, I will use <span class="in">`jwdid`</span> for both specifications. Because by default <span class="in">`jwdid`</span> produces the fully saturated model, I will omit those results, showing only the average treatment effect.</span>
<span id="cb16-173"><a href="#cb16-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-174"><a href="#cb16-174" aria-hidden="true" tabindex="-1"></a>First the one using not-yet treated units as controls (default), which produces exactly the same results as the two-step approach:</span>
<span id="cb16-175"><a href="#cb16-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-178"><a href="#cb16-178" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb16-179"><a href="#cb16-179" aria-hidden="true" tabindex="-1"></a><span class="in">*| code-fold: false</span></span>
<span id="cb16-180"><a href="#cb16-180" aria-hidden="true" tabindex="-1"></a><span class="in">*ssc install jwdid</span></span>
<span id="cb16-181"><a href="#cb16-181" aria-hidden="true" tabindex="-1"></a><span class="in">qui: jwdid y, ivar(i) tvar(t) gvar(g)</span></span>
<span id="cb16-182"><a href="#cb16-182" aria-hidden="true" tabindex="-1"></a><span class="in">estat simple</span></span>
<span id="cb16-183"><a href="#cb16-183" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-184"><a href="#cb16-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-185"><a href="#cb16-185" aria-hidden="true" tabindex="-1"></a>Second the one with never treated units as controls:</span>
<span id="cb16-186"><a href="#cb16-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-189"><a href="#cb16-189" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb16-190"><a href="#cb16-190" aria-hidden="true" tabindex="-1"></a><span class="in">*| code-fold: false</span></span>
<span id="cb16-191"><a href="#cb16-191" aria-hidden="true" tabindex="-1"></a><span class="in">qui: jwdid y, ivar(i) tvar(t) gvar(g) never</span></span>
<span id="cb16-192"><a href="#cb16-192" aria-hidden="true" tabindex="-1"></a><span class="in">estat simple</span></span>
<span id="cb16-193"><a href="#cb16-193" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-194"><a href="#cb16-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-195"><a href="#cb16-195" aria-hidden="true" tabindex="-1"></a><span class="fu">### 2x2 on Steroids</span></span>
<span id="cb16-196"><a href="#cb16-196" aria-hidden="true" tabindex="-1"></a><span class="fu">#### @callaway_santanna_2021 `csdid` &amp; `csdid2`</span></span>
<span id="cb16-197"><a href="#cb16-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-198"><a href="#cb16-198" aria-hidden="true" tabindex="-1"></a>The third option is the most computing intensive, but at the same time simpler to understand, if you break it down to the basics. This is why I call this 2x2 in Steroids: @callaway_santanna_2021.</span>
<span id="cb16-199"><a href="#cb16-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-200"><a href="#cb16-200" aria-hidden="true" tabindex="-1"></a>The literature on the 2x2 DID design has been extensively explored and extended, and it appears that most of the criticisms of the TWFE method do not apply to this simple design. Although there are a few technical details to consider while estimating ATT's, most of the information required can be found in @santanna_doubly_2020. In this work, the authors provide several options for obtaining the best estimate from a simple 2x2 DID design.</span>
<span id="cb16-201"><a href="#cb16-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-202"><a href="#cb16-202" aria-hidden="true" tabindex="-1"></a>Assuming that we know how to execute 2x2 DID correctly (which can be achieved using <span class="in">`drdid`</span> in Stata), @callaway_santanna_2021 propose that we focus on estimating all the good and useful 2x2 DID designs from our data while avoiding incorrect comparisons. These are the building blocks of the methodology, the ATTGTs. This are the average treatment effects on the treated for units treated for the first time in period G, but measured at period T.</span>
<span id="cb16-203"><a href="#cb16-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-204"><a href="#cb16-204" aria-hidden="true" tabindex="-1"></a>This process, however, could be time-consuming and computationally intensive if done manually, as the number of 2x2 designs increases with the number of cohorts and periods available in the data. For example, estimating 50 different ATTs would be necessary with 5 cohorts and 10 periods, and up to 5 separate models need to be estimated for each ATT. </span>
<span id="cb16-205"><a href="#cb16-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-206"><a href="#cb16-206" aria-hidden="true" tabindex="-1"></a>Borrowing from the nomenclature in @callaway_santanna_2021, this ATTGT's are defined as follows:</span>
<span id="cb16-207"><a href="#cb16-207" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-208"><a href="#cb16-208" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb16-209"><a href="#cb16-209" aria-hidden="true" tabindex="-1"></a>    ATT(g,t) &amp;= E(Y_{i,t}|i\in g) - E(Y_{i,g-1}|i\in g) <span class="sc">\\</span></span>
<span id="cb16-210"><a href="#cb16-210" aria-hidden="true" tabindex="-1"></a>             &amp; -\Big<span class="co">[</span><span class="ot"> E(Y_{i,t}|i\in C) - E(Y_{i,g-1}|i\in C) \Big</span><span class="co">]</span></span>
<span id="cb16-211"><a href="#cb16-211" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb16-212"><a href="#cb16-212" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-213"><a href="#cb16-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-214"><a href="#cb16-214" aria-hidden="true" tabindex="-1"></a>Which has the same structure as the simple 2x2 DID, with the difference that the control group $C$ will be formed by never treated units only, or include those not yet treated ( $i \in g_i, g_i&gt;t, \And \  g_i&gt;g$).^<span class="co">[</span><span class="ot">There are two other options, but I will leave them for a different post</span><span class="co">]</span></span>
<span id="cb16-215"><a href="#cb16-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-216"><a href="#cb16-216" aria-hidden="true" tabindex="-1"></a>Once all individual ATTGT's have been identified and estimated, providing summary measures we are more familiar with is as easy as obtaining weighted averages:</span>
<span id="cb16-217"><a href="#cb16-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-218"><a href="#cb16-218" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-219"><a href="#cb16-219" aria-hidden="true" tabindex="-1"></a>SATT = \sum \left( \frac{w_{gt} }{\sum w_{gt}}ATT(g,t) \right)</span>
<span id="cb16-220"><a href="#cb16-220" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb16-221"><a href="#cb16-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-222"><a href="#cb16-222" aria-hidden="true" tabindex="-1"></a>where the weights $w_{gt}$ will change based on the type of aggregation one is interested in. </span>
<span id="cb16-223"><a href="#cb16-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-224"><a href="#cb16-224" aria-hidden="true" tabindex="-1"></a>This multiple stage process may seem challening, but there are tools that allow you to implement them quite easily: <span class="in">`csdid`</span> and <span class="in">`csdid2`</span>. </span>
<span id="cb16-225"><a href="#cb16-225" aria-hidden="true" tabindex="-1"></a>The first one, was written as a wrapper around <span class="in">`drdid`</span>, to do all the heavy lifting for you. However, for large projects, it can be slow due to overhead. The alternative <span class="in">`csdid2`</span> is self contained, still under development, but much faster than the predecesor. See <span class="co">[</span><span class="ot">`csdid2`</span><span class="co">](https://github.com/friosavila/csdid2)</span> if interested. Here I will use <span class="in">`csdid`</span>, which you can get from SSC.</span>
<span id="cb16-226"><a href="#cb16-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-227"><a href="#cb16-227" aria-hidden="true" tabindex="-1"></a>As with <span class="in">`jwdid`</span>. The default option is for <span class="in">`csdid`</span> to produce all ATTGT's. So, for the excercise, I'll omit that ouput, and estimate the aggregate effects with the post estimation command. The default is to use the never treated as controls. I will also add the option <span class="in">`long2`</span> to obtain the pre-treatment ATTGT's as describe above, even though they won't affect our point estimates:</span>
<span id="cb16-230"><a href="#cb16-230" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb16-231"><a href="#cb16-231" aria-hidden="true" tabindex="-1"></a><span class="in">*| code-fold: false</span></span>
<span id="cb16-232"><a href="#cb16-232" aria-hidden="true" tabindex="-1"></a><span class="in">qui: ssc install drdid, replace</span></span>
<span id="cb16-233"><a href="#cb16-233" aria-hidden="true" tabindex="-1"></a><span class="in">qui: ssc install csdid, replace</span></span>
<span id="cb16-234"><a href="#cb16-234" aria-hidden="true" tabindex="-1"></a><span class="in">qui: csdid y, ivar(i) time(t) gvar(g) long2</span></span>
<span id="cb16-235"><a href="#cb16-235" aria-hidden="true" tabindex="-1"></a><span class="in">estat simple </span></span>
<span id="cb16-236"><a href="#cb16-236" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-237"><a href="#cb16-237" aria-hidden="true" tabindex="-1"></a>I will also use the not yet treated, to compare results.</span>
<span id="cb16-240"><a href="#cb16-240" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb16-241"><a href="#cb16-241" aria-hidden="true" tabindex="-1"></a><span class="in">*| code-fold: false</span></span>
<span id="cb16-242"><a href="#cb16-242" aria-hidden="true" tabindex="-1"></a><span class="in">qui: csdid y, ivar(i) time(t) gvar(g) notyet long2</span></span>
<span id="cb16-243"><a href="#cb16-243" aria-hidden="true" tabindex="-1"></a><span class="in">estat simple </span></span>
<span id="cb16-244"><a href="#cb16-244" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb16-245"><a href="#cb16-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-246"><a href="#cb16-246" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusions</span></span>
<span id="cb16-247"><a href="#cb16-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-248"><a href="#cb16-248" aria-hidden="true" tabindex="-1"></a>On this occasion, I have shared with you three solutions from the literature that aim to overcome the limitations of TWFE. Although there are other solutions available, I personally find these three to be the most intuitive and have worked on them. Granted, I have some bias on the matter.</span>
<span id="cb16-249"><a href="#cb16-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-250"><a href="#cb16-250" aria-hidden="true" tabindex="-1"></a>Despite their apparent differences, these solutions actually converge towards similar outcomes, with discrepancies arising from variations in assumptions regarding control groups or covariate management.</span>
<span id="cb16-251"><a href="#cb16-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-252"><a href="#cb16-252" aria-hidden="true" tabindex="-1"></a>|command | eq command|</span>
<span id="cb16-253"><a href="#cb16-253" aria-hidden="true" tabindex="-1"></a>|---|---|</span>
<span id="cb16-254"><a href="#cb16-254" aria-hidden="true" tabindex="-1"></a>|<span class="in">`jwdid`</span> | <span class="in">`did2s`</span> &amp; <span class="in">`did_imputation`</span>|</span>
<span id="cb16-255"><a href="#cb16-255" aria-hidden="true" tabindex="-1"></a>|<span class="in">`jwdid, never`</span> | <span class="in">`eventstudyinteract`</span>|</span>
<span id="cb16-256"><a href="#cb16-256" aria-hidden="true" tabindex="-1"></a>|<span class="in">`jwdid, never`</span> | <span class="in">`csdid, long2`</span> or <span class="in">`csdid2, long`</span>  |</span>
<span id="cb16-257"><a href="#cb16-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-258"><a href="#cb16-258" aria-hidden="true" tabindex="-1"></a><span class="fu">## References</span></span>
<span id="cb16-259"><a href="#cb16-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-260"><a href="#cb16-260" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb16-261"><a href="#cb16-261" aria-hidden="true" tabindex="-1"></a>:::</span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>